1. Handling method calls

    var SquareGame game;
    # ...
    do game.run();

In the snippet above the last should generate the following vm:

    call SquareGame.run 1

The following code handles this translation:

    def compile_term...

        # ...

        elif tkn_nxt.text == ' ( ' or tkn_nxt.text == ' . ':
        self.calling_method = False
        if self.cur_tkn.text == " . ":
            # term -> className '.' subroutineName '(' expressionList ')'
            # (a SUBROUTINE call)
            # .jack: PongGame.newInstance()
            # .vm:   function PongGame.newInstance

            # term -> varName '.' subroutineName '(' expressionList ')'
            # (a METHOD call)
            # .jack: do game.run()
            # .vm:   function PongGame.run 1


            ######################################
            tkn_txt = tkn_txt.strip()
            if self.symbol_table.recognises_symbol(tkn_txt):
                symbol_type = self.symbol_table.type_of(tkn_txt)
                if symbol_type not in BUILT_IN_TYPES:
                    var_or_class_name = symbol_type
                    num_expressions = 1
            #######################################
            self._eat_symbol(".")
            subroutine_name = self._eat_identifier()
        else:
            # term -> subroutineName '(' expressionList ')'
            # (a METHOD call)
            # .jack: do moveBall()
            # .vm    function PongGame.moveBall 5
            pass

We've established that it's either (i) className.subroutineName(...) or (ii) varName.subroutineName(...). In
 the first case, we're dealing with a function call, in the second, we're dealing with a method call on an
 instance. If the symbol tkn_txt is not in the symbol table we assume we're dealing with a function call (which includes
 ``new``), if it is in the table we assume we're dealing with a method call

 #################      #################       #################      #################       #################

2. Understanding if, and if-else

Compile the conditional expression, and immediately after it, place an 'if-goto IF_TRUE*'. If the conditional
evaluates to true this if-goto is enacted and execution will jump to the code block that follows the if statement.
We need to write the IF_TRUE* label just above the vm code that represents this code block, but before we do that
we need to handle the possibility that the conditional expression evaluates to false, in which case we have to avoid
the vm code that immediately follows 'if'. To do this, immediately after 'if-goto IF_TRUE*' we write a goto 'IF_FALSE*'.
This goto will be jumped over (ignored) whenver if evalutates to true, but whenever if evaluates to false it will be
executed.

So now we know where to put the goto statements, we now need to place the labels that represent the destinations of
these jumps. IF_TRUE* is simply placed immediately after 'goto IF_FALSE0', and the statements that make up the if-true
code-block then follow it. IF_FALSE* needs to be placed immediately after the if-true code-block.